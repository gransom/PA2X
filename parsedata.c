#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#ifdef DATAPARSE
#include "parse-inc/config-structs.h"			// generated by the pre-parse tool
#include "parse-inc/path-names.inc"			// generated by the pre-parse tool
#include "parse-inc/struct-names.inc"			// generated by the pre-parse tool

#include "confpars-structs.h"
#include "confpars.h"
#include "defaults.h"
#include "parse-types.h"

int *pathIdxLst(char *path)
{
char *b_ptr; 
int i, b_cnt = 0, *idxLst;

b_ptr = strstr(path, "[");				// point at first opening '[' bracket

if (b_ptr == (char *)NULL)				// if it is no list ...
   return (int *)NULL;					//                  ... we don't have an index list

while (b_ptr != (char *)NULL) {				// as long as we have indices
   b_cnt++;						// count them
   b_ptr = strstr(b_ptr+1, "[");			// find next one
   }

if (b_cnt == 0)
   idxLst = (int *)NULL;				// nothing here, return NULL
else
   idxLst = (int *)malloc((b_cnt + 1) * sizeof(int));	// return a EOL/-1 terminated list

b_ptr = path;
for (i=0; i< b_cnt; i++) {
   b_ptr = strstr(b_ptr, "[");				// find next index
   b_ptr++;						// point at the int
   if (b_ptr[0] == ']')
      idxLst[i] = INCOMPLETE;				// no index, must be a template
   else
      idxLst[i] = atoi(b_ptr);				// convert to integer (malformed integers will be 0!
   }
idxLst[b_cnt] = EOL;					// terminate the lsit

return idxLst;						// return it
}



int pathIdx(char *str)
{
int i=0, max_idx=sizeof(configFields)/sizeof(char *);	// counter....  and there are this many nested fields

while (i < max_idx)					// we only know of these many things
   if (strcmp(configFields[i++], str) == 0)		// Do we have a match?
      return --i;					// index of where this match is
return -1;						// I have no idea what you're talking about
}



int structIdx(char *str)
{
int i=0, max_idx=sizeof(configStructs)/sizeof(char *);	// counter....  and there are this many nested fields

while (i < max_idx)					// we only know of these many things
   if (strcmp(configStructs[i++], str) == 0)		// Do we have a match?
      return --i;					// index of where this match is
return -1;						// I have no idea what you're talking about
}



void *structAllocByIdx(int struct_idx)
{
void *ptr;

#ifdef DEBUG
printf("Allocation Idx = %d\n", struct_idx);
#endif

switch(struct_idx) {					// take the switch for this struct
   #include "parse-inc/struct-switch.inc"		// include switch body
   default: return (void *)NULL; break;			// default for in case something went wronmg
   }
return (void *)NULL;					// nothing worked, broken, return NULL.
}



void *structAlloc(char *name)
{
return structAllocByIdx(structIdx(name));		
}



void **addStruct(void **dsLst, void *dStruct)			// add a struct to a configuration
{								//   ...  for example a repo to a config struct
int r_cnt;

if (dsLst == (void **)NULL) {					// do we have a list?
#ifdef DEBUG
   printf("first addition.\n");
#endif
   dsLst = (void **)malloc(2*sizeof(void *));			// nope, allocate memory for 2 ptrs, last one terminates
   if (dsLst == (void **)NULL) {
      printf("ERROR: allocating memory.\n");
      exit(-1);
      }
   r_cnt = 1;							// indexes in the list used, including terminating 0;
   }
else {
#ifdef DEBUG
   printf("Consecutive addition.\n");
#endif

   r_cnt = 0;                                                   // we already have a list
   while (dsLst[r_cnt] != (void *)NULL) r_cnt++;                // count index range, starting with 0 including the terminating NULL
   r_cnt++;
   dsLst = (void **)realloc(dsLst, (r_cnt+1)*sizeof(void *));	// reallocate memory for one more spot
   if (dsLst == (void **)NULL) {
      printf("ERROR: reallocating memory.\n");
      exit(-1);
      }
   }

dsLst[r_cnt-1] = dStruct;					// add the pointer to the structure
dsLst[r_cnt]   = (void *)NULL;					// terminate the list

return dsLst;           
}




void *memberSwitchParse(char *path, struct config *config, int *idx, int sw_task)	
{
int field = pathIdx(path);
int i, idxStatus = VALID;

if (idx != (int *) NULL) {					// if we have an index list
   i = 0;
   while (idx[i] != EOL) {					// interate till the end of list
      if (idx[i] == INCOMPLETE)					// check if we have an incomplete index
         idxStatus = INCOMPLETE;				// set the ixdStatus for all nVTL types with leaves
      i++;							// next!!
      }
   }

#ifdef DEBUG
printf("member switch case: %d\n", field);
#endif

switch(field) {										// switch to where we know what to do with this value
   #include "parse-inc/path-switch.inc"							// generated by the pre-parse tool
   default: {
#ifdef DEBUG
      printf("switch issue: %s\n", path);
#endif
      return (void *)NULL;								// we don't have this member
      };
   }
return (void *)NULL;									// return the index of what we know
}



void *getMemberPtr(char *path, struct config *config) {
int i, *idxLst;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);							// create path template

idxLst = pathIdxLst(path);								// get template index
ptr =  memberSwitchParse(pline, config, idxLst, GET_PTR);				// return pointer to struct or member/field

if (idxLst != (int *)NULL) {
#ifdef DEBUG
   for (i = 0; idxLst[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxLst[i]);
#endif
   free(idxLst);									// free our index list
   }

#ifdef DEBUG
if (ptr == (void *) NULL)
   printf("returning a null pointer\n");
#endif

return ptr;
}


void *getListMemberPtr(char *path, struct config *config) {
int i, *idxLst;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);							// create path template

idxLst = pathIdxLst(path);								// get template index
ptr =  memberSwitchParse(pline, config, idxLst, GET_LST_MBR_PTR);			// return pointer to struct or member/field

if (idxLst != (int *)NULL) {
#ifdef DEBUG
   for (i = 0; idxLst[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxLst[i]);
#endif
   free(idxLst);									// free our index list
   }   

#ifdef DEBUG
if (ptr == (void *) NULL)
   printf("returning a null pointer\n");
#endif

return ptr;
}



void *fMemberPtr(char *path, struct config *config) {
int i, *idxLst;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);							// create path template

idxLst = pathIdxLst(path);								// get template index
ptr =  memberSwitchParse(pline, config, idxLst, GET_F_PTR);				// return pointer to struct or member/field

if (idxLst != (int *)NULL) {
#ifdef DEBUG
   for (i = 0; idxLst[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxLst[i]);
#endif
   free(idxLst);									// free our index list
   }

#ifdef DEBUG
if (ptr == (void *) NULL)
   printf("returning a null pointer\n");
#endif

return ptr;
}



char **deleteDoubleEntries(char **cf_list)
{
int i, j, max_idx=sizeof(configFields)/sizeof(char *);					// this looks like cheating but cf_list and
char *first, *second;									// configFields always are the same length

for (i = 0; i < max_idx; i++) {								// for all entries
   first = cf_list[i];									// for this entry
   if (strlen(first) != 0) {								// if it really is an entry still
      for (j = i+1; j < max_idx; j++) {							// for all entries 
         second = cf_list[j];								//                 after the first entry
         if (strcmp(first, second) == 0) {						// if they are the same
            second[0] = 0;								// get rid of the second one
            }
         }
      }
   }
return cf_list;
}



int findSubStructure(int idx, char **cf_list)
{
int i, max_idx=sizeof(configFields)/sizeof(char *);					// this looks like cheating but cf_list and
char *first, *second;									// configFields always are the same length

if (idx >= max_idx)
   return EOL_ERR;									// this is bad.
if (strlen(cf_list[idx]) == 0)
   return NULL_PATH;									// empty is part of anything and nothing

first = cf_list[idx];									// we have a real one
for (i = 0; i < max_idx; i++) {								// for all others
   second = cf_list[i];
   if (strlen(second) > 0) {								// we don't check empty paths
      if (strncmp(first, second, strlen(first)) == 0) {					// second a sub struct of first?
         if (strlen(first) < strlen(second)) {						// but not identical
            if ( (second[strlen(first)] == '-'  && second[strlen(first)+1] == '>') ||	// check if
                  second[strlen(first)] == '.' ||					//    it has
                  second[strlen(first)] == '[') {					//       actual members
               return i;								// yup
               }
            }
         }
      }
   }

return idx;										// nothing found return our own index
}



int typevNTL(char *path)
{
int i, subStrIdx, max_idx=sizeof(configStructs)/sizeof(char *);
char *vNTL_ptr;

if (strlen(path) == 0)
   return -1;

#ifdef DEBUG
 printf("enter typevNTL:%s\n", path);
#endif

for (i = 0; i < max_idx; i++) {
   vNTL_ptr = strstr(path, configStructs[i]);
   if (vNTL_ptr != (char *)NULL) {
      if ((vNTL_ptr + strlen(configStructs[i]))[0] == '[' &&			// must be a list ....
          (vNTL_ptr + strlen(configStructs[i]))[1] == ']' &&			//                .... definition
          (vNTL_ptr + strlen(configStructs[i]))[2] == 0 ) {			// a vNTL type is always a list like [] at the end of definition
#ifdef DEBUG
         printf("%s is a vNTL type\n", path);
#endif
         return 1;
         }
      }
   }

return 0;
}



int getRecursionLevel(char *path)
{
int reclvl = -1;								// -1 is root level, no list
char *reclvl_ptr;								// for pointing at indices

reclvl_ptr = strstr(path, "[");							// find first index
while (reclvl_ptr != (char *)NULL) {
   reclvl++;									// count them (start with 0)
   reclvl_ptr=strstr(reclvl_ptr+1, "[");					// find the others
   }

return reclvl;
}



int __pa2xAllocated(char *path, struct varNameTypeList *vNTL)
{
char varName[64];
int isvNTL = 0, lstMbr = 0;
struct varNameTypeList *c_ptr;

if (vNTL == (struct varNameTypeList *)NULL)
   return 0;

isvNTL = typevNTL(path);

getVarNameFromPath(path, varName);

c_ptr = vNTL;
while (c_ptr->next != (struct varNameTypeList *)NULL) {
   c_ptr = c_ptr->next;
   if (strcmp(varName, c_ptr->varName) == 0)
      lstMbr = 1;
   }

if (isvNTL == 0 && lstMbr == 1) {
#ifdef DEBUG
   printf("__pa2xAllocated: %s was not dynamically allocated\n", varName);
#endif
   return 0;
   }
else {
#ifdef DEBUG
   printf("__pa2xAllocated: %s was dynamically allocated\n", varName);
#endif
   return 1;
   }
}



char *getPathParent(char *path)
{
char *parent, *ref_ptr;

parent = (char *)malloc((strlen(path)+1) * sizeof(char));

strcpy(parent, path);
ref_ptr = &(parent[strlen(parent)]);
while (ref_ptr > parent && ref_ptr[0] != '>')           // as long as we're in the string and didn't find the '>'
      ref_ptr--;                                                // walk back

if (ref_ptr[0] == '>')
   ref_ptr--;                                           // go to the "-"

ref_ptr[0] = 0;                                         // truncate  either just before ->  or at parent[0]

return parent;
}



void freeConfigvNTL(char *cf_line, struct config *cfg, int lvl, struct varNameTypeList *vNTL, int vNTL_stat, int verbose)
{
int i, j, max_idx=sizeof(configFields)/sizeof(char *);
int level, rec_lvl, path_lvl, isvNTL, *idx, vNTL_mbr, done;
char **fld_ptr, *vNTL_tail_str, *vNTL_head_str, *lvl_lst_ptr, *vNTL_str, *vNTL_org_str, idx_str[16];
void **vNTL_ptr, *idxPtr;

level = lvl + 1;								// every recursion step we're a level higher
rec_lvl = getRecursionLevel(cf_line);						// find recursion level count in this path

if (rec_lvl == -1) {
   fld_ptr = getMemberPtr(cf_line, cfg);					// get root level var pointer
   if (*fld_ptr != (char *)NULL) {
#ifdef DEBUG
      printf("static: %s; free(%s)\n", cf_line, *fld_ptr);
#endif
      free(*fld_ptr);								// it is in use, free it
      *fld_ptr = (char *)NULL;							// set it to NULL
      }
   }
else {
   vNTL_str = (char *)malloc((strlen(cf_line) + 16) * sizeof(char));	// and vNTL string a bit longer for index
   strcpy(vNTL_str, cf_line);
   lvl_lst_ptr = strstr(vNTL_str, "[]");					// first one is our level
   if (lvl_lst_ptr != (void *)NULL) {						// should ALWAYS be true
      vNTL_tail_str = (char *)malloc((strlen(lvl_lst_ptr) + 16) * sizeof(char));	// create the tail of the path
      strcpy(vNTL_tail_str, lvl_lst_ptr+2);					// copy it
      *lvl_lst_ptr = 0;								// truncate this
      vNTL_org_str = (char *)malloc((strlen(cf_line) + 16) * sizeof(char));
      strcpy(vNTL_org_str, vNTL_str);
      vNTL_head_str = getPathParent(cf_line);
      strcat(vNTL_str, "[]");							// name list / switch trick
      isvNTL = typevNTL(vNTL_head_str);						// check if we are vNTL struct
      if (isvNTL == 1) {
         vNTL_ptr = getMemberPtr(vNTL_str, cfg);
         vNTL_str[strlen(vNTL_str)-2] = 0;					// strip repo trick off
         if (vNTL_ptr != (void **)NULL) {					// do we have an actual list?
            vNTL_mbr = 0;
            done = 0;
            while (! done) {
               sprintf(idx_str, "[%d]", vNTL_mbr);				// print the index part
               strcpy(vNTL_str, vNTL_org_str);				// reset vNTL path
               strcat(vNTL_str, idx_str);					// set the new index
               idxPtr=getListMemberPtr(vNTL_str, cfg);			// get ptr to list member
               if (idxPtr != (void *)NULL) {
                  strcat(vNTL_str, vNTL_tail_str);				// check leaf path
                  fld_ptr = getMemberPtr(vNTL_str, cfg);
                  if ((void **)fld_ptr != (void **) NULL) {			// is this is an actual path ?
                     if (__pa2xAllocated(vNTL_str, vNTL) == 1) {
                        if (verbose == VERBOSE) {
                           if (vNTL_stat == VNTL_ACTV)
                              printf("vNTL field (actv): %s free(%s)\n", vNTL_str, *fld_ptr);
                           if (vNTL_stat == VNTL_EMPT)
                              printf("vNTL dlist (orph): free(%s)\n", vNTL_str);
                           free(*fld_ptr);					// free this member/leaf
                           }
                        }
                     }
                  else {
                     if (rec_lvl != level) {
#ifdef DEBUG
                        printf("Recursion: (%s)\n", vNTL_str);
#endif
                        freeConfigvNTL(vNTL_str, cfg, rec_lvl, vNTL, vNTL_stat, verbose);
                        }
                     } 
                  }
               else {
                  done = 1;							// NULL found, end of list.
                  }
               vNTL_mbr++;							// go to next struct in the list
               }
            }
         }
      else {
         vNTL_ptr = getMemberPtr(vNTL_str, cfg);
         if (vNTL_ptr != (void **) NULL) {
            printf("vNTL dlist (orph): free(%s)\n", vNTL_str);
            getMemberPtr(vNTL_str, cfg);
            //free(nVTL_ptr);
            }
         }
      free(vNTL_tail_str);							// free tail of vNTL path
      free(vNTL_org_str);							// free original vNTL path
      }
   free(vNTL_str);								// free vNTL path
   }
}



struct line *freeConfigStructContent(struct config *cfg, struct varNameTypeList *vNTL, int verbose)
{
int i, vNTL_type, vNTL_stat, subStrIdx, subStr_fnd;
int max_idx=sizeof(configFields)/sizeof(char *);					// counter....  and there are this many nested fields
char **v_ptr, **cf_list, *cf_ll, *dref_ptr, *field, *str_ptr;
void **vNTL_ptr;

cf_list = (char **)malloc(max_idx * sizeof(char *));					// we need a copy of configFields
for (i = 0; i < max_idx; i++) {
   cf_list[i] = malloc((strlen(configFields[i]) +1) * sizeof(char));
   strcpy(cf_list[i], configFields[i]);							// copy var path
   }

subStr_fnd = 1;
while (subStr_fnd == 1) {
   subStr_fnd = 0;
   deleteDoubleEntries(cf_list);                                                        // delete all double entries in our configFields copy
   for (i = 0; i < max_idx; i++) {                                                      // for every configField entry
      subStrIdx = findSubStructure(i, cf_list);                                         // check to see if we're part of something
      vNTL_stat = VNTL_ACTV; 								// assume vNTL is active
#ifdef DEBUG
      printf("Sub Struct check: %d <=> %d %s\n", i, subStrIdx, cf_list[i]);
#endif
      if (subStrIdx == i) {
         if (typevNTL(cf_list[i]) == 1) {						// there are no sub structs anymore
            vNTL_stat=VNTL_EMPT;							// no children/leaves left
            }
         if (strlen(cf_list[i]) > 0) {
            freeConfigvNTL(cf_list[i], cfg, -1, vNTL, vNTL_stat, verbose);		// freeConfigvNTL(list, config, root)   -1 is for root level
            str_ptr = cf_list[i];						// point at current list entry
            str_ptr[0] = 0;								// remove path
            }
         }
      else {
         if (subStrIdx >= 0)
            subStr_fnd = 1;
         }
      }
   }

for (i = 0; i < max_idx; i++)								// free all
   free(cf_list[i]);									//          the strings again.
free(cf_list);										// and the list itself

return (struct line *)NULL;                                                             // I have no idea what you're talking about
}



void **listObjByName(char *objName, struct config *config)
{
int  max_idx=sizeof(configFields)/sizeof(char *);			// number of entries is sizeof 'it' divided by size of a char pointer
int i, f_match = 0, e_match = 0, ptr_cnt = 0;
char *c_ptr, *cb_ptr;
void **ptr_list;

ptr_list = (void **) malloc((max_idx +1) * sizeof(void *));		// create a list for possibly all objects plus one for the terminating spot
memset((void *)ptr_list, 0x00, (max_idx + 1)  * sizeof(void *));	// wipe the list clean

for (i = 0; i < max_idx; i++) {						// for every entry in the list
   c_ptr = strstr(configFields[i], objName);
   if (c_ptr != (char *)NULL) {						// is it at least a substring?
      f_match = 0;
      e_match = 0;
      if (c_ptr == configFields[i])					// we have the same starting point,     front match (but never really happens)
         f_match = 1;
      else {
         if ((c_ptr - 1)[0] == '.')
            f_match = 1;						// we're a struct member                front match
         if ((c_ptr - 1)[0] == '>')
            if ((c_ptr - 2)[0] == '-')					// we might be a struct member
               f_match = 1;
         }
      c_ptr += strlen(objName);						// c_ptr is pointing at the position AFTER the last character
      if (c_ptr[0] == 0)
         e_match = 1;							// var name ends here,                  end math.
      if (c_ptr[0] == '.')						// struct name ends here,               end match.
         e_match = 1;
      if (c_ptr[0] == '[') {						// this is a list,  start
         cb_ptr = strstr(c_ptr, "]");
         if (cb_ptr != (char *)NULL) {					// this is the first find, so closing for previous bracket
            cb_ptr += 1;						// point at position AFTER the string
            if (cb_ptr[0] == 0)						// name of a list,                      end match
              e_match = 1;
            }
         }
      if (c_ptr[0] == '-')
         if (c_ptr[1] == '>')						// possible struct ptr member
            e_match = 1;						// it is                                end match
      if (f_match == 1 && e_match == 1) {
#ifdef DEBUG
         printf("listObjByName: %s -- %s\n", configFields[i], objName);
#endif
         ptr_list[ptr_cnt] = getMemberPtr(configFields[i], config);
         ptr_cnt++;
         ptr_list[ptr_cnt] = (void *)NULL;
         }
      }
   }
return ptr_list;
}



void freeObjByNameList(void **ptrLst)
{
int i;
void *ptr;
int maxIdx = sizeof(ptrLst)/sizeof(void *);

if (ptrLst != (void *)NULL) {
   for (i=0; i <= maxIdx; i++) {
      ptr = ptrLst[i];
      if (ptr != (void *)NULL)
         free(ptr);
      }
    free(ptrLst);
    }

}
#endif
