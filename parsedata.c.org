#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#ifdef DATAPARSE
#include "parse-inc/config-structs.h"			// generated by the pre-parse tool
#include "parse-inc/path-names.inc"			// generated by the pre-parse tool
#include "parse-inc/struct-names.inc"			// generated by the pre-parse tool

#include "confpars-structs.h"
#include "confpars.h"
#include "defaults.h"
#include "parse-types.h"

int *pathIdxLst(char *path)
{
char *b_ptr; 
int i, b_cnt = 0, *idxLst;

b_ptr = strstr(path, "[");				// point at first opening '[' bracket

if (b_ptr == (char *)NULL)
   return (int *)NULL;

while (b_ptr != (char *)NULL) {
   b_cnt++;						// count it
   b_ptr = strstr(b_ptr+1, "[");			// find next one
   }

if (b_cnt == 0)
   idxLst = (int *)NULL;				// nothing here, return NULL
else {
   idxLst = (int *)malloc((b_cnt + 1) * sizeof(int));	// return a -1 terminated list
   }

b_ptr = path;
for (i=0; i< b_cnt; i++) {
   b_ptr = strstr(b_ptr, "[");				// find next index
   b_ptr++;
   idxLst[i] = atoi(b_ptr);				// convert to integer
   }
idxLst[b_cnt] = -1;					// terminate the lsit

return idxLst;						// return it
}



int pathIdx(char *str)
{
int i=0, max_idx=sizeof(configFields)/sizeof(char *);	// counter....  and there are this many nested fields

while (i < max_idx)					// we only know of these many things
   if (strcmp(configFields[i++], str) == 0)		// Do we have a match?
      return --i;					// index of where this match is
return -1;						// I have no idea what you're talking about
}



int structIdx(char *str)
{
int i=0, max_idx=sizeof(configStructs)/sizeof(char *);	// counter....  and there are this many nested fields

while (i < max_idx)					// we only know of these many things
   if (strcmp(configStructs[i++], str) == 0)		// Do we have a match?
      return --i;					// index of where this match is
return -1;						// I have no idea what you're talking about
}



void *structAllocByIdx(int struct_idx)
{
void *ptr;

#ifdef DEBUG
printf("Allocation Idx = %d\n", idx);
#endif

switch(struct_idx) {					// take the switch for this struct
   #include "parse-inc/struct-switch.inc"		// include switch body
   default: return (void *)NULL; break;			// default for in case something went wronmg
   }
return (void *)NULL;					// nothing worked, broken, return NULL.
}



void *structAlloc(char *name)
{
return structAllocByIdx(structIdx(name));
}



void **addStruct(void **dsLst, void *dStruct)			// add a struct to a configuration
{								//   ...  for example a repo to a config struct
int r_cnt;

if (dsLst == (void **)NULL) {					// do we have a list?
#ifdef DEBUG
   printf("first addition.\n");
#endif
   dsLst = (void **)malloc(2*sizeof(void *));			// nope, allocate memory for 2 ptrs, last one terminates
   if (dsLst == (void **)NULL) {
      printf("ERROR: allocating memory.\n");
      exit(-1);
      }
   r_cnt = 1;							// indexes in the list used, including terminating 0;
   }
else {
#ifdef DEBUG
   printf("Consecutive addition.\n");
#endif

   r_cnt = 0;                                                   // we already have a list
   while (dsLst[r_cnt] != (void *)NULL) r_cnt++;                // count index range, starting with 0 including the terminating NULL
   r_cnt++;
   dsLst = (void **)realloc(dsLst, (r_cnt+1)*sizeof(void *));	// reallocate memory for one more spot
   if (dsLst == (void **)NULL) {
      printf("ERROR: reallocating memory.\n");
      exit(-1);
      }
   }

dsLst[r_cnt-1] = dStruct;					// add theapointer to the structure
dsLst[r_cnt]   = (void *)NULL;					// terminate the list

return dsLst;           
}




void *memberSwitchParse(char *path, struct config *config, int *idx, int sw_task)
{
int field = pathIdx(path);
char *val_buff;

#ifdef DEBUG
printf("member switch case: %d\n", field);
#endif

switch(field) {										// switch to where we know what to do with this value
   #include "parse-inc/path-switch.inc"							// generated by the pre-parse tool
   default: {
printf("switch issue: %s\n", path);
      return (void *)NULL;								// we don't have this member
      };
   }
return (void *)NULL;									// return the index of what we know
}



void *getMemberPtr(char *path, struct config *config) {
int i, *idxLst;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);							// create path template

idxLst = pathIdxLst(path);								// get template index
ptr =  memberSwitchParse(pline, config, idxLst, GET_PTR);				// return pointer to struct or member/field

if (idxLst != (int *)NULL) {
#ifdef DEBUG
   for (i = 0; idxLst[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxLst[i]);
#endif
   free(idxLst);
   }

return ptr;
}


void *getListMemberPtr(char *path, struct config *config) {
int i, *idxLst;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);                                                     // create path template

idxLst = pathIdxLst(path);                                                              // get template index
ptr =  memberSwitchParse(pline, config, idxLst, GET_LST_MBR_PTR);                               // return pointer to struct or member/field

if (idxLst != (int *)NULL) {
//#ifdef DEBUG
   for (i = 0; idxLst[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxLst[i]);
//#endif
   free(idxLst);
   }   

return ptr;
}



void *fMemberPtr(char *path, struct config *config) {
int i, *idxList;
void *ptr;
char pline[TMP_BUFF_SZ];

str2NamesListTemplate(path, pline);

idxList = pathIdxLst(path);
ptr =  memberSwitchParse(pline, config, idxList, GET_F_PTR);				// return pointer to struct or member/field

if (idxList != (int *)NULL) {
#ifdef DEBUG
   for (i = 0; idxList[i] >= 0; i++)
      printf("idx[%d] = %d\n", i, idxList[i]);
#endif
   free(idxList);
   }

return ptr;
}



char **deleteDoubleEntries(char **cf_list)
{
int i, j, max_idx=sizeof(configFields)/sizeof(char *);					// this looks like cheating, but they are always the same
char *first, *second;

for (i = 0; i < max_idx; i++) {								// for all entries
   first = cf_list[i];									// for this entry
   if (strlen(first) != 0) {								// if it really is an entry still
      for (j = i+1; j < max_idx; j++) {							// for all entries 
         second = cf_list[j];								//                 after the first entry
         if (strcmp(first, second) == 0) {						// if they are the same
            second[0] = 0;								// get rid of the second one
            }
         }
      }
   }
return cf_list;
}



int findSubStructure(int idx, char **cf_list)
{
int i, max_idx=sizeof(configFields)/sizeof(char *);					// this looks like cheating, but they are always the same
char *first, *second;

if (idx >= max_idx)
   return -1;										// this is bad.
if (strlen(cf_list[idx]) == 0)
   return -1;										// empty is part of anything and nothing

first = cf_list[idx];									// we have a real one
for (i = 0; i < max_idx; i++) {								// for all others
   second = cf_list[i];									//               like this one
   if (strncmp(first, second, strlen(first)) == 0) {					// and I could be a sub path
      if (strlen(first) < strlen(second) && strlen(second) > 0) {			// if I could be part of it .. the
         if (! (second[strlen(first)+1] == '-' ||					//    struct pointer
                second[strlen(first)+1] == '.' ||					//    or a struct member
                second[strlen(first)+1] == '[' )) {					//    or a list member
            return i;									// we're part of this vNTL path
            }
         }
      }
   }

return idx;
}



int typevNTL(char *path)
{
int i, subStrIdx, max_idx=sizeof(configStructs)/sizeof(char *);
char *vNTL_ptr;

if (strlen(path) == 0)
   return -1;

#ifdef DEBUG
 printf("enter typevNTL:%s\n", path);
#endif

for (i = 0; i < max_idx; i++) {
   vNTL_ptr = strstr(path, configStructs[i]);
   if (vNTL_ptr != (char *)NULL) {
      if ((vNTL_ptr + strlen(configStructs[i]))[0] == '[' &&			// must be a list ....
          (vNTL_ptr + strlen(configStructs[i]))[1] == ']' &&			//                .... definition
          (vNTL_ptr + strlen(configStructs[i]))[2] == 0 ) {			// a vNTL type is always a list like [] at the end of definition
#ifdef DEBUG
         printf("%s is a vNTL type\n", path);
#endif
         return 1;
         }
      }
   }

return 0;
}



void freeCfgvNTL(char *v_ptr, struct config *cfg)									// free some[]thing[]like[]this
{
int i, reclvl, *idx, done = 0, isvNTL, max_idx=sizeof(configFields)/sizeof(char *);
char *br_ptr, **fld_ptr, indexStr[16], strPath[128], strMemberPath[128], varName[32];
void **lst_ptr, **stc_ptr;

if (v_ptr == (char *)NULL)
   return;

reclvl=-1;										// we start with -1, because the first pair of '[]' is index 0
br_ptr = strstr(v_ptr, "[]");								// find the first bracket
while (br_ptr != (char *)NULL) {							// while we keep finding list brackets
   reclvl++;										// increase "recursion level"
   br_ptr = strstr(br_ptr+2, "[]");							// point to next list bracket pair
   }

if (reclvl >= 0) {									// if a list is actually defined
   idx = (int *)malloc((reclvl+1) * sizeof(int));					// create index list for the list
   for (i = 0; i <= reclvl; i++)							// for all spots in the index list
      idx[i] = 0;									// set to 0


   lst_ptr = memberSwitchParse(v_ptr, cfg, idx, GET_PTR);                               // get pointer to the list

   if (*lst_ptr != (void *)NULL) {
      while (! done) {									// for every vNTL structure in the list
         strcpy(strPath, v_ptr);							// copy the member path
         isvNTL = typevNTL(strPath);							// check
         strPath[strlen(strPath)-2] = 0;						// remove trigger
         sprintf(indexStr, "[%d]", idx[reclvl]);
//         strcpy(indexStr, "[]");
//#ifdef DEBUG
printf("strPath: %s\n", strPath);
printf("Idx:     %s\n", indexStr);
//#endif
         if (isvNTL == 1)
            strcat(strPath, indexStr);
printf("strPath: %s\n", strPath);
         *stc_ptr = getListMemberPtr(strPath, cfg);					// find the pointer for this vNTL structure
         for (i = 0; i < max_idx; i++) {						// find it's structure members
            if (strncmp(configFields[i], v_ptr, strlen(v_ptr)) == 0 &&			// is this path way ...
               strlen(v_ptr) < strlen(configFields[i]))  {				//                  ... an actual struct member ?
               strcpy(strMemberPath, strPath);						// reset structure member path every time before we start with new member
//#ifdef DEBUG
               printf("getMemberPtr (*stc_ptr): %s  stc_ptr: [%p] [%d]\n", strPath, *stc_ptr, idx[reclvl]);
//#endif
               if (*stc_ptr != (void *)NULL) {						// non initialised struct
                  getVarNameFromPath(configFields[i], varName);				// get the field variable name
                  strcat(strMemberPath, "->");						// and add ..
                  strcat(strMemberPath, varName);					//         .. to the path name
                  fld_ptr = getMemberPtr(strMemberPath, cfg);				// get the struct member's/field's pointer
                  if (*fld_ptr != (char *)NULL) {					// if it is in use ..
//#ifdef DEBUG
                     printf ("Free-ing: %s <==> %s\n", strMemberPath, *fld_ptr);	
//#endif
                     free(*fld_ptr);							// we free it here
                     }
                  }
               else {
                  done = 1;								// stop (while loop) iterating through list
                  i = max_idx;								// stop (for loop) iterating
                  }
               }
            }
         free(*stc_ptr);								// we don't need this vNTL structure anymore
         stc_ptr[idx[reclvl]] = 0;							// set entry to NULL
         idx[reclvl]++;									// advance the semi-dummy index list
         }
      }
   free(idx);										// we don't need the index anymore
   }
}



void freeConfigvNTL(char **cf_list, struct config *cfg)
{
int i, vNTL_type, subStrIdx, subStr_fnd, max_idx=sizeof(configFields)/sizeof(char *);	// this looks like cheating, but they are always the same
char *str_ptr;
void **vNTL_ptr;

subStr_fnd = 1;

while (subStr_fnd == 1) {
   subStr_fnd = 0;
   deleteDoubleEntries(cf_list);							// delete all double entries in our configFields copy
   for (i = 0; i < max_idx; i++) {							// for every configField entry
      subStrIdx = findSubStructure(i, cf_list);						// check to see if we're part of something
      if (subStrIdx == i) {								// there is no super structure, we can free this list...
         str_ptr = cf_list[i];								// and ....
         vNTL_type = typevNTL(str_ptr);
         if (vNTL_type == 1) {								// if this is a vNTL type struct
//#ifdef DEBUG
            printf("Freeing vNTL struct members: %s\n", str_ptr);
//#endif
            freeCfgvNTL(str_ptr, cfg);
printf("done.\n");
            vNTL_ptr = getMemberPtr(str_ptr, cfg);
            if (vNTL_ptr != (void **)NULL) {
//#ifdef DEBUG
               printf("Free-ing: %s\n", str_ptr);
//endif
//               free(vNTL_ptr);								// free the list itself
               vNTL_ptr = (void **)NULL;
               }
            str_ptr[0] = 0;
            }
         }
      else {
         if (subStrIdx >= 0)
            subStr_fnd = 1;
         }

      if (strlen(cf_list[i]) != 0 && vNTL_type != 1) {
//#ifdef DEBUG
         printf("NOT a vNTL type: %s\n", cf_list[i]);
//#endif
         str_ptr = cf_list[i];
         str_ptr[0] = 0;
         }
      }
   }
}



struct line *freeConfigStructContent(struct config *cfg, struct varNameTypeList *vNTL)
{
int i, max_idx=sizeof(configFields)/sizeof(char *);					// counter....  and there are this many nested fields
char **v_ptr, **cf_list, *dref_ptr, *field;

cf_list = (char **)malloc(max_idx * sizeof(char *));					// we need a copy of configFields
for (i = 0; i < max_idx; i++) {
   cf_list[i] = malloc((strlen(configFields[i]) +1) * sizeof(char *));
   strcpy(cf_list[i], configFields[i]);							// copy var path
   field = cf_list[i];									// point to start of var path
   dref_ptr = field + strlen(field);							// point to last char of that var path
   while (dref_ptr > field && dref_ptr[0] != '>')					// walk back to the last '->' but not past start
      dref_ptr--;
   if (dref_ptr > field && dref_ptr[0] == '>') {					// if we're pointing right at the field
      dref_ptr--;
      if (dref_ptr[0] == '-')
         dref_ptr[0] = 0;								// and truncate it
      }
   }

freeConfigvNTL(cf_list, cfg);

for (i = 0; i < max_idx; i++)								// free all
   free(cf_list[i]);									//          the strings again.
free(cf_list);										// and the list itself

return (struct line *)NULL;                                                             // I have no idea what you're talking about
}



void **listObjByName(char *objName, struct config *config)
{
int  max_idx=sizeof(configFields)/sizeof(char *);			// number of entries is sizeof 'it' divided by size of a char pointer
int i, f_match = 0, e_match = 0, ptr_cnt = 0;
char *c_ptr, *cb_ptr;
void **ptr_list;

ptr_list = (void **) malloc((max_idx +1) * sizeof(void *));		// create a list for possibly all objects plus one for the terminating spot
memset((void *)ptr_list, 0x00, (max_idx + 1)  * sizeof(void *));	// wipe the list clean

for (i = 0; i < max_idx; i++) {						// for every entry in the list
   c_ptr = strstr(configFields[i], objName);
   if (c_ptr != (char *)NULL) {						// is it at least a substring?
      f_match = 0;
      e_match = 0;
      if (c_ptr == configFields[i])					// we have the same starting point,     front match (but never really happens)
         f_match = 1;
      else {
         if ((c_ptr - 1)[0] == '.')
            f_match = 1;						// we're a struct member                front match
         if ((c_ptr - 1)[0] == '>')
            if ((c_ptr - 2)[0] == '-')					// we might be a struct member
               f_match = 1;
         }
      c_ptr += strlen(objName);						// c_ptr is pointing at the position AFTER the last character
      if (c_ptr[0] == 0)
         e_match = 1;							// var name ends here,                  end math.
      if (c_ptr[0] == '.')						// struct name ends here,               end match.
         e_match = 1;
      if (c_ptr[0] == '[') {						// this is a list,  start
         cb_ptr = strstr(c_ptr, "]");
         if (cb_ptr != (char *)NULL) {					// this is the first find, so closing for previous bracket
            cb_ptr += 1;						// point at position AFTER the string
            if (cb_ptr[0] == 0)						// name of a list,                      end match
              e_match = 1;
            }
         }
      if (c_ptr[0] == '-')
         if (c_ptr[1] == '>')						// possible struct ptr member
            e_match = 1;						// it is                                end match
      if (f_match == 1 && e_match == 1) {
#ifdef DEBUG
         printf("listObjByName: %s -- %s\n", configFields[i], objName);
#endif
         ptr_list[ptr_cnt] = getMemberPtr(configFields[i], config);
         ptr_cnt++;
         ptr_list[ptr_cnt] = (void *)NULL;
         }
      }
   }
return ptr_list;
}



void freeObjByNameList(void **ptrLst)
{
int i;
void *ptr;
int maxIdx = sizeof(ptrLst)/sizeof(void *);

if (ptrLst != (void *)NULL) {
   for (i=0; i <= maxIdx; i++) {
      ptr = ptrLst[i];
      if (ptr != (void *)NULL)
         free(ptr);
      }
    free(ptrLst);
    }

}
#endif
